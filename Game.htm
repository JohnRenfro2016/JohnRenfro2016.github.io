<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Simple RPG Game</title>
<style>

/* Style for all textarea elements */
textarea {
    max-height: 300px; /* Set the maximum height for the textarea */
    overflow-y: auto; /* Enable vertical scrolling */
    border: 1px solid #ccc; /* Add a border for visibility */
}

/* Style for the scrollbar track */
textarea::-webkit-scrollbar {
    width: 6px; /* Set the width of the scrollbar */
}

/* Style for the scrollbar handle */
textarea::-webkit-scrollbar-thumb {
    background-color: #888; /* Set the color of the handle */
}

/* Style for the scrollbar track on hover */
textarea::-webkit-scrollbar-track:hover {
    background-color: #f0f0f0; /* Set the color of the track on hover */
}

.statsArea {
  background-color: black;
  color: white;
  border: 1px solid #000;
  padding: 10px;
  position: absolute;
  top: 120px; /* Adjust the position as needed */
  left: 0;
  z-index: 2;
}

.hidden {
  display: none;
}

.custom-file-upload {
    cursor: pointer;
    color: #eedd82; /* Gold color for treasure chest */
}

.custom-file-upload input[type="file"] {
    display: none;
}

.custom-file-upload:hover {
    background-color: #f0f0f0;
}

button, html, input {
    background-color: #8b4513; /* Dark brown color for background (old wood) */
    color: #eedd82; /* Gold color for treasure chest */
    display: inline-block;
    font-size: 10px;
    opacity: 0.8; /* Slightly reduce opacity for a vintage look */
}

body {
    background-color: #8b4513; /* Dark brown color for background (old wood) */
}

.character {
    background-color: #8b4513; /* Brown color for character */
    width: 100px;
    height: 100px;
    border: 1px solid #8b4513; /* Brown color for borders */
    position: absolute;
    touch-action: none;
    z-index: 1;
}

.diceResult {
    color: #eedd82; /* Gold color for text */
    display: inline-block;
    font-size: 14px;
    margin-left: 10px;
}

.diceRoller {
    margin-top: 10px;
}

.diceRoller input[type="text"] {
    width: 10ch;
}

.dragArea {
    background-color: rgba(139, 69, 19, 0.5); /* Semi-transparent brown color for drag area */
    color: #eedd82; /* Gold color for text */
    cursor: move;
    position: relative;
}

.gameBoard {
    background-color: #8b4513; /* Dark brown color for background (old wood) */
    display: grid;
    grid-template-columns: repeat(7, 100px);
    grid-template-rows: repeat(7, 100px);
    height: 700px;
    position: relative;
    width: 700px;
}

.gameControls {
    display: flex;
}

.inputField, .DiceInputField {
    background: transparent;
    border: none;
    color: #eedd82; /* Gold color for treasure chest */
}

.inputField {
    width: 12ch;
}

.DiceInputField {
    width: 10ch;
}

.rotateButton {
    background: none;
    border: none;
    color: #eedd82; /* Gold color for text */
    cursor: pointer;
    padding: 0;
}

.rotateButton:hover {
    background-color: #f0f0f0;
}

.square {
    border: 1px solid #8b4513; /* Brown color for borders */
    box-sizing: border-box;
    height: 100px;
    width: 100px;
}

a {
    color: #eedd82; /* Gold color for links */
    text-decoration: none; /* Remove default underline */
    transition: color 0.3s; /* Add transition for smoother hover effect */
}

a:hover {
    color: #f0f0f0; /* Lighter shade for hover effect */
}

/* Placeholder text color */
::placeholder {
    color: #eedd82; /* Gold color for treasure chest */
}

</style>
</head>
<body>
<a href='https://archive.org/details/tsr02011advanceddungeonsdragonsadd1steddungeonmastersguide/page/n74/mode/1up' target='_blank'>Dungeon Master Guide Combat Tables</a>
|
<a href='https://archive.org/details/ad-d-monster-manual' target='_blank'>Monster Manual</a>
|
<a href='https://archive.org/details/tsr09045addthesecretofbonehill' target='_blank'>The Secret of Bone Hill</a>
|
<div class="gameControls">
<input type="file" id="mapImageInput" accept="image/*">
<button id="createCharacterButton">Create Character</button>
<button id="saveButton">Save Game</button>
</div>
<div class="diceRoller">Attack Dice:
  <input id="diceNotationInput" type="text" maxlength="10" placeholder="XdY+Z" value="1d20+0">
  <span id="diceResult" class="diceResultStyle"></span>
</div>

<div class="gameBoard" id="gameBoard">
<!-- Add squares dynamically with JavaScript -->
</div>

<script>

const mapImageInput = document.getElementById('mapImageInput');
const gameBoard = document.getElementById('gameBoard');

mapImageInput.addEventListener('change', handleMapImageSelection);

function handleMapImageSelection(event) {
  const file = event.target.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = function() {
      const imageUrl = reader.result;
      gameBoard.style.backgroundImage = `url(${imageUrl})`;
      
      // Save map image URL in local storage
      localStorage.setItem('mapImage', imageUrl);
    };
    reader.readAsDataURL(file);
  }
}

// Roll dice function
function rollDice2(diceNotation) {
  const [numDice, diceSize, constant] = diceNotation.split(/[d+]/).map(Number);
  let result = constant || 0;

  for (let i = 0; i < numDice; i++) {
    result += Math.floor(Math.random() * diceSize) + 1;
  }

  return result;
}

document.addEventListener('DOMContentLoaded', function() {

  // Add event listener for dice input field
  const diceInput = document.getElementById('diceNotationInput');
  const diceResultElement = document.getElementById('diceResult');

  // Calculate dice result on mouseout
  diceInput.addEventListener('mouseout', () => {
    const diceNotation = diceInput.value;
    if (diceNotation) {
      const result = rollDice2(diceNotation);
      diceResultElement.textContent = `Result: ${result}`;
    }
  });
});

document.addEventListener('DOMContentLoaded', function() {
const gameControls = document.querySelector('.gameControls');
const gameBoard = document.getElementById('gameBoard');
const createCharacterButton = document.getElementById('createCharacterButton');
const saveButton = document.getElementById('saveButton');
let pieceCount = 0;

// Create a character
function createCharacter(x, y) {
pieceCount++;
const character = document.createElement('div');
character.className = 'character';
character.style.left = x + 'px';
character.style.top = y + 'px';
character.id = `piece${pieceCount}`;



const imageSelectButton = document.createElement('input');
imageSelectButton.type = 'file';
imageSelectButton.accept = 'image/*';
imageSelectButton.addEventListener('change', (event) => handleImageSelection(event, character));

const label = document.createElement('label');
label.className = 'custom-file-upload'; // Apply custom styling if needed
label.appendChild(imageSelectButton);
label.appendChild(document.createTextNode('M')); // Set the label text

character.appendChild(label);
gameBoard.appendChild(character);
	
	 // Function to handle image selection
function handleImageSelection(event, character) {
const file = event.target.files[0];
if (file) {
const reader = new FileReader();
reader.onload = function() {
const imageUrl = reader.result;
character.style.backgroundImage = `url(${imageUrl})`;

// Save game state after image selection
saveGameState();
};
reader.readAsDataURL(file);
}
}

//Add drag area
const dragArea = document.createElement('span');
dragArea.className = 'dragArea';
dragArea.textContent = 'Drag';
character.appendChild(dragArea);
	
// Add rotation button
const rotateButton = document.createElement('button');
rotateButton.className = 'rotateButton'; 
rotateButton.textContent = 'R';
rotateButton.addEventListener('click', () => rotateCharacter(character.id));
character.appendChild(rotateButton);

const statsButton = document.createElement('button');
statsButton.className = 'statsButton'; 
statsButton.textContent = 'Stats';
statsButton.addEventListener('click', () => toggleStats(character.id));
character.appendChild(statsButton);

const statsArea = document.createElement('div');
statsArea.className = 'statsArea hidden'; // Initially hidden
statsArea.style.zIndex = 2;
statsArea.innerHTML = `
  <div>more content hereAC</div>
`;
character.appendChild(statsArea);

// Add textarea for stats
const inputField = document.createElement('textarea');
inputField.className = 'inputField';
inputField.rows = 4; // Set the number of rows
inputField.maxLength = '120'; // Adjust the maximum length if needed
inputField.placeholder = 'Name AC HD maxHP/curHP';
inputField.id = `input_${pieceCount}`; // Assigning a unique ID
statsArea.appendChild(inputField);
	
// Add dice input field
const diceInput = document.createElement('input');
diceInput.className = 'DiceInputField';
diceInput.type = 'text';
diceInput.maxLength = '10';
diceInput.placeholder = 'XdY+Z';
statsArea.appendChild(diceInput);

// Add dice result element
const diceResult = document.createElement('span');
diceResult.className = 'diceResult';
statsArea.appendChild(diceResult);

// Calculate dice result on mouseout
diceInput.addEventListener('mouseout', () => {
const diceNotation = diceInput.value;
if (diceNotation) {
const result = rollDice(diceNotation);
diceResult.textContent = `=${result}`;
}
});

// Add duplication button
const duplicateButton = document.createElement('button');
duplicateButton.textContent = 'New dice roll?';
duplicateButton.className = 'duplicateButton';
statsArea.appendChild(duplicateButton);

duplicateButton.addEventListener('click', () => {
  const newDiceInput = diceInput.cloneNode(true);
  const newDiceResult = diceResult.cloneNode(true);

  statsArea.appendChild(newDiceInput);
  statsArea.appendChild(newDiceResult);

  newDiceInput.addEventListener('mouseout', () => {
    const diceNotation = newDiceInput.value;
    if (diceNotation) {
      const result = rollDice(diceNotation);
      newDiceResult.textContent = `=${result}`;
    }
  });
});

// Add delete button
const deleteButton = document.createElement('button');
deleteButton.className = 'rotateButton'; 
deleteButton.textContent = 'X';
deleteButton.addEventListener('click', () => deleteCharacter(character.id));
statsArea.appendChild(deleteButton);
	
gameBoard.appendChild(character);

function toggleStats(id) {
  const character = document.getElementById(id);
  const statsArea = character.querySelector('.statsArea');
  statsArea.classList.toggle('hidden');
}

// Make character draggable
let isDragging = false;
let isDraggingStats = false;
let draggedCharacter = null;

function handleMouseDown(event) {
    if (event.target.classList.contains('dragArea')) {
        isDragging = true;
        draggedCharacter = event.target.parentElement;
        draggedCharacter.style.zIndex = 2;
        const rect = draggedCharacter.getBoundingClientRect();
        offsetX = event.clientX - rect.left;
        offsetY = event.clientY - rect.top;
    } else if (event.target.classList.contains('statsButton')) {
        isDraggingStats = true;
        draggedCharacter = event.target.parentElement;
        draggedCharacter.style.zIndex = 2;
    }
}

function handleMouseMove(event) {
    if (isDragging) {
        const newX = event.clientX - offsetX;
        const newY = event.clientY - offsetY;
        draggedCharacter.style.left = newX + 'px';
        draggedCharacter.style.top = newY + 'px';
    }
}

function handleMouseUp() {
    if (isDragging || isDraggingStats) {
        isDragging = false;
        isDraggingStats = false;
        draggedCharacter.style.zIndex = 1;
        draggedCharacter = null;
    }
}

function handleTouchStart(event) {
    if (event.target.classList.contains('dragArea')) {
        event.preventDefault();
        isDragging = true;
        draggedCharacter = event.target.parentElement;
        draggedCharacter.style.zIndex = 2;
        const rect = draggedCharacter.getBoundingClientRect();
        offsetX = event.touches[0].clientX - rect.left;
        offsetY = event.touches[0].clientY - rect.top;
    } else if (event.target.classList.contains('statsButton')) {
        isDraggingStats = true;
        draggedCharacter = event.target.parentElement;
        draggedCharacter.style.zIndex = 2;
    }
}

function handleTouchMove(event) {
    if (isDragging) {
        const newX = event.touches[0].clientX - offsetX;
        const newY = event.touches[0].clientY - offsetY;
        draggedCharacter.style.left = newX + 'px';
        draggedCharacter.style.top = newY + 'px';
    }
}

function handleTouchEnd() {
    if (isDragging || isDraggingStats) {
        isDragging = false;
        isDraggingStats = false;
        draggedCharacter.style.zIndex = 1;
        draggedCharacter = null;
    }
}

document.addEventListener('mousemove', handleMouseMove);
document.addEventListener('touchmove', handleTouchMove);

document.addEventListener('mouseup', handleMouseUp);
document.addEventListener('touchend', handleTouchEnd);

dragArea.addEventListener('mousedown', (event) => {
isDragging = true;
offsetX = event.offsetX;
offsetY = event.offsetY - 20; // Adjusted for the px offset
});

document.addEventListener('mousemove', (event) => {
if (isDragging) {
const newX = event.clientX - offsetX;
const newY = event.clientY - offsetY;

character.style.left = newX + 'px';
character.style.top = newY + 'px';
}
});

document.addEventListener('mouseup', () => {
isDragging = false;
});

character.ondragstart = function() {
return false;
};
}

// Delete a character
function deleteCharacter(id) {
const character = document.getElementById(id);
character.remove();

// Update local storage
saveGameState();
}

// Rotate a character
function rotateCharacter(id) {
const character = document.getElementById(id);
let rotation = character.dataset.rotation || 0;
rotation = (parseInt(rotation) + 45) % 360;
character.style.transform = `rotate(${rotation}deg)`;
character.dataset.rotation = rotation;
}

// Roll dice function
function rollDice(diceNotation) {
const [numDice, diceSize, constant] = diceNotation.split(/[d+]/).map(Number);
let result = constant || 0;

for (let i = 0; i < numDice; i++) {
result += Math.floor(Math.random() * diceSize) + 1;
}

return result;
} 

function saveGameState() {
const characters = gameBoard.querySelectorAll('.character');
const gameState = [];

characters.forEach(character => {
const id = character.id;
const x = character.offsetLeft;
const y = character.offsetTop;
const rotation = character.dataset.rotation || 0;
const ac = character.querySelector('.inputField').value || '';
const diceInput = character.querySelector('.DiceInputField').value || '';
const diceResult = character.querySelector('.diceResult').textContent || '';
const imageUrl = character.style.backgroundImage.replace('url("', '').replace('")', '');

        const diceInputsArray = Array.from(diceInputs).map(input => input.value);
        const diceResultsArray = Array.from(diceResults).map(result => result.textContent);

gameState.push({ id, x, y, rotation, ac, diceInput, diceResult, imageUrl, diceInputsArray, diceResultsArray });
});

localStorage.setItem('gameState', JSON.stringify(gameState));
}

saveButton.addEventListener('click', () => {
  saveGameState();
  saveMapImage();
});

function saveMapImage() {
  const mapImageUrl = gameBoard.style.backgroundImage.replace('url("', '').replace('")', '');
  localStorage.setItem('mapImage', mapImageUrl);
}

function loadGameState() {
const gameState = JSON.parse(localStorage.getItem('gameState'));

  const mapImageUrl = localStorage.getItem('mapImage');

  if (mapImageUrl) {
    gameBoard.style.backgroundImage = `url(${mapImageUrl})`;
  }

if (gameState) {
gameState.forEach(({ id, x, y, rotation, ac, diceInput, diceResult, imageUrl }) => {
createCharacter(x, y);

const character = document.getElementById(id);
character.dataset.rotation = rotation;
character.style.transform = `rotate(${rotation}deg)`;
character.querySelector('.inputField').value = ac;
character.querySelector('.DiceInputField').value = diceInput;
character.querySelector('.diceResult').textContent = diceResult;
character.style.backgroundImage = `url(${imageUrl})`; // Set the background image
});
}
}

// Add event listener for create character button
createCharacterButton.addEventListener('click', () => {
const x = Math.floor(Math.random() * 600); // Random x position (between 0 and 600)
const y = Math.floor(Math.random() * 600); // Random y position (between 0 and 600)
createCharacter(x, y);
});

// Add event listener for save button
saveButton.addEventListener('click', saveGameState);

// Load game state when page loads
loadGameState();
});
</script>

</body>
</html>